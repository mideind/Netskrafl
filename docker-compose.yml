# docker-compose.yml - Local development environment for Netskrafl/Explo
#
# Usage:
#   docker compose up              # Start app + Redis
#   docker compose up -d           # Start in background
#   docker compose up --scale app=3  # Run 3 app instances
#   docker compose logs -f app     # Follow app logs
#   docker compose down            # Stop and remove containers
#   docker compose watch           # Start with live file sync (dev mode)
#
# Prerequisites:
#   1. DAWG files must exist: python utils/dawgbuilder.py all
#   2. GCP credentials file at ./credentials/service-account.json
#      (or set GOOGLE_CREDENTIALS_BASE64 environment variable)

# No version key needed - Compose V2 infers it automatically

services:

  # ===========================================================================
  # Main application
  # ===========================================================================
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      # Project ID - override with: PROJECT_ID=explo-dev docker compose up
      PROJECT_ID: ${PROJECT_ID:-netskrafl}
      # Redis connection (uses service name as hostname)
      REDIS_URL: redis://redis:6379
      # Not "local" in the GAE sense - use production-like settings
      RUNNING_LOCAL: "false"
      # Version string for cache busting
      APP_VERSION: ${APP_VERSION:-docker-dev}
      # Credentials: mount file or pass base64-encoded via environment
      GOOGLE_APPLICATION_CREDENTIALS: /app/credentials/service-account.json
      # Uncomment to use base64 credentials instead of mounted file:
      # GOOGLE_CREDENTIALS_BASE64: ${GOOGLE_CREDENTIALS_BASE64}
    volumes:
      # Mount credentials directory (create ./credentials/service-account.json)
      - ./credentials:/app/credentials:ro
    depends_on:
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health/live"]
      interval: 30s
      timeout: 10s
      start_period: 90s
      start_interval: 5s
      retries: 3
    # Live file sync for development (use with: docker compose watch)
    develop:
      watch:
        # Sync source code changes
        - action: sync
          path: ./src
          target: /app/src
        # Sync template changes
        - action: sync
          path: ./templates
          target: /app/templates
        # Rebuild on requirements change
        - action: rebuild
          path: ./requirements.txt

  # ===========================================================================
  # Redis cache
  # ===========================================================================
  redis:
    image: redis:7-alpine
    # Uncomment to expose Redis for debugging (may conflict with local Redis)
    # ports:
    #   - "6379:6379"
    volumes:
      - redis-data:/data
    command: >
      redis-server
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
      --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      start_period: 5s
      retries: 3

  # ===========================================================================
  # Nginx load balancer (for scaled deployments)
  # ===========================================================================
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    profiles:
      - scaled  # Only start with: docker compose --profile scaled up
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/nginx-health"]
      interval: 30s
      timeout: 5s
      retries: 3

volumes:
  redis-data:

# Networks are created automatically
# All services can reach each other by service name (app, redis, nginx)
